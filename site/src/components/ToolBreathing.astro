---
interface Props {
    tool: any;
}

const { tool } = Astro.props;
const phases = tool.steps ?? [];
const baseCycles = tool.repeat ?? 4;

const phaseCopy = {
    inhale: 'Inhale',
    hold: 'Hold',
    exhale: 'Exhale'
};

const totalCycleSeconds = phases.reduce((total, phase) => total + (phase.duration ?? 0), 0);
---

<section class="space-y-5" data-breathing-root>
    <div class="flex items-center justify-between text-sm text-slate-800">
        <span data-cycle-display>Cycle 1 of {baseCycles}</span>
        <span data-total-remaining>~{totalCycleSeconds * baseCycles}s total</span>
    </div>

    <div class="breathing-stage" data-phase={phases[0]?.phase ?? 'inhale'}>
        <div class="breathing-ring" data-preview-area>
            <svg class="ring" viewBox="0 0 200 200" role="presentation">
                <circle cx="100" cy="100" r="88" class="ring-track" />
                <circle cx="100" cy="100" r="88" class="ring-progress" data-progress-ring />
            </svg>
            <div class="breathing-core" data-breath-circle>
                <div class="text-[13px] uppercase tracking-wide text-emerald-800 font-semibold" data-phase-label>
                    {phaseCopy[phases[0]?.phase] ?? 'Inhale'}
                </div>
                <div class="text-5xl font-bold text-gray-900 leading-none" data-phase-count>
                    {phases[0]?.duration ?? 4}
                </div>
                <div class="text-sm text-slate-800 mt-2 font-semibold" data-phase-instruction>
                    Inhale for {phases[0]?.duration ?? 4}
                </div>
            </div>
        </div>
        <p class="text-center text-sm text-slate-800 mt-3 font-medium">
            Breathe in through your nose, breathe out slowly through your mouth.
        </p>
        <p class="text-center text-xs text-emerald-700 mt-1">Tap the circle for a quick preview before you start.</p>
    </div>

    <div class="flex flex-wrap justify-center gap-3">
        <button
            type="button"
            class="control-btn primary"
            data-start-btn
        >
            Start
        </button>
        <button
            type="button"
            class="control-btn muted"
            data-pause-btn
            aria-disabled="true"
        >
            Pause
        </button>
        <button
            type="button"
            class="control-btn ghost"
            data-restart-btn
        >
            Restart
        </button>
    </div>

    <div class="space-y-4">
        <div>
            <p class="text-sm font-semibold text-gray-800 mb-2">Cycles</p>
            <div class="flex flex-wrap gap-2" data-cycle-selector>
                {[3,4,5,6].map((count) => (
                    <button
                        type="button"
                        class={`toggle-chip ${count === baseCycles ? 'active' : ''}`}
                        data-cycle-value={count}
                        aria-pressed={count === baseCycles}
                    >
                        {count} cycles
                    </button>
                ))}
            </div>
        </div>

        <div class="grid grid-cols-2 sm:grid-cols-3 gap-2">
            <button type="button" class="toggle-chip" data-toggle="sound" aria-pressed="false">Sound off</button>
            <button type="button" class="toggle-chip" data-toggle="vibration" aria-pressed="false">Vibration off</button>
            <button type="button" class="toggle-chip" data-toggle="voice" aria-pressed="false">Voice off</button>
            <button type="button" class="toggle-chip" data-toggle="contrast" aria-pressed="false">High contrast</button>
            <button type="button" class="toggle-chip" data-toggle="reduce" aria-pressed="false">Reduced motion</button>
        </div>
    </div>
</section>

<style>
    .breathing-stage {
        background: linear-gradient(180deg, #ffffff, #f7faf9);
        border-radius: 1rem;
        padding: 1rem;
        border: 1px solid rgba(0,0,0,0.04);
        box-shadow: 0 10px 28px rgba(0,0,0,0.06), 0 0 24px rgba(99, 102, 241, 0.06);
    }

    .breathing-ring {
        position: relative;
        width: min(82vw, 280px);
        height: min(82vw, 280px);
        margin: 0 auto;
    }

    .ring {
        position: absolute;
        inset: 0;
        transform: rotate(-90deg);
    }

    .ring-track {
        fill: none;
        stroke: rgba(15, 118, 110, 0.12);
        stroke-width: 10;
        stroke-linecap: round;
    }

    .ring-progress {
        fill: none;
        stroke: #10b981;
        stroke-width: 10;
        stroke-linecap: round;
        stroke-dasharray: 553;
        stroke-dashoffset: 553;
        transition: stroke 200ms ease;
    }

    .breathing-core {
        position: absolute;
        inset: 14%;
        border-radius: 9999px;
        background: radial-gradient(circle at 40% 30%, rgba(16,185,129,0.18), rgba(255,255,255,0.96)), #e0f2fe;
        box-shadow: 0 0 0 12px rgba(16, 185, 129, 0.14), 0 20px 44px rgba(59,130,246,0.1);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        text-align: center;
        transition: box-shadow 360ms ease, background 360ms ease;
        transform: scale(var(--scale, 1));
    }

    [data-phase="inhale"] .breathing-core {
        background: radial-gradient(circle at 40% 30%, rgba(16,185,129,0.2), rgba(224, 242, 254, 0.98));
        box-shadow: 0 0 0 14px rgba(16, 185, 129, 0.2), 0 18px 40px rgba(59,130,246,0.12);
    }

    [data-phase="hold"] .breathing-core {
        background: radial-gradient(circle at 60% 30%, rgba(52,211,153,0.2), rgba(224, 242, 254, 0.98));
        box-shadow: 0 0 0 12px rgba(52, 211, 153, 0.18), 0 18px 36px rgba(59,130,246,0.1);
    }

    [data-phase="exhale"] .breathing-core {
        background: radial-gradient(circle at 30% 20%, rgba(125,211,252,0.18), rgba(240,253,250,0.96));
        box-shadow: 0 0 0 10px rgba(14,165,233,0.16), 0 18px 32px rgba(59,130,246,0.08);
    }

    .control-btn {
        min-width: 96px;
        border-radius: 999px;
        padding: 0.7rem 1.2rem;
        font-weight: 700;
        font-size: 0.95rem;
        border: 1px solid transparent;
        box-shadow: 0 8px 20px rgba(0,0,0,0.08);
        transition: transform 140ms ease, box-shadow 160ms ease, background 180ms ease;
    }

    .control-btn.primary {
        background: linear-gradient(120deg, #10b981, #22d3ee);
        color: white;
    }

    .control-btn.muted {
        background: #eef2ff;
        color: #4338ca;
        border-color: rgba(67,56,202,0.16);
    }

    .control-btn.ghost {
        background: white;
        color: #0f172a;
        border: 1px solid rgba(0,0,0,0.07);
    }

    .control-btn[aria-disabled="true"] {
        opacity: 0.6;
        box-shadow: none;
    }

    .control-btn:not([aria-disabled="true"]):active {
        transform: translateY(1px);
        box-shadow: 0 4px 10px rgba(0,0,0,0.06);
    }

    .toggle-chip {
        padding: 0.55rem 0.9rem;
        border-radius: 999px;
        font-weight: 600;
        font-size: 0.9rem;
        border: 1px solid rgba(0,0,0,0.08);
        background: white;
        color: #0f172a;
        box-shadow: 0 4px 10px rgba(0,0,0,0.04);
        transition: transform 120ms ease, background 160ms ease, border-color 160ms ease, color 160ms ease;
    }

    .toggle-chip.active,
    .toggle-chip[aria-pressed="true"] {
        background: linear-gradient(120deg, #ecfeff, #d1fae5);
        border-color: rgba(16,185,129,0.35);
        color: #065f46;
        box-shadow: 0 8px 20px rgba(16,185,129,0.12);
    }

    [data-high-contrast="true"] .breathing-stage {
        border-color: rgba(0,0,0,0.12);
        box-shadow: 0 12px 28px rgba(0,0,0,0.12);
    }

    [data-high-contrast="true"] .ring-track {
        stroke: rgba(0,0,0,0.45);
    }

    [data-high-contrast="true"] .ring-progress {
        stroke: #0f172a;
    }

    @media (prefers-reduced-motion: reduce) {
        .breathing-core,
        .control-btn,
        .toggle-chip,
        .ring-progress {
            transition: none !important;
        }
    }
</style>

<script define:vars={{ phases, baseCycles, phaseCopy, totalCycleSeconds }}>
    const root = document.querySelector('[data-breathing-root]');
    const ring = document.querySelector('[data-progress-ring]');
    const circle = document.querySelector('[data-breath-circle]');
    const phaseLabel = document.querySelector('[data-phase-label]');
    const phaseInstruction = document.querySelector('[data-phase-instruction]');
    const phaseCount = document.querySelector('[data-phase-count]');
    const stage = document.querySelector('.breathing-stage');
    const cycleDisplay = document.querySelector('[data-cycle-display]');
    const remainingDisplay = document.querySelector('[data-total-remaining]');
    const startBtn = document.querySelector('[data-start-btn]');
    const pauseBtn = document.querySelector('[data-pause-btn]');
    const restartBtn = document.querySelector('[data-restart-btn]');
    const cycleButtons = document.querySelectorAll('[data-cycle-value]');
    const toggleChips = document.querySelectorAll('[data-toggle]');
    const previewArea = document.querySelector('[data-preview-area]');

    const prefersReduced = window.matchMedia('(prefers-reduced-motion: reduce)');

    const settings = {
        targetCycles: baseCycles,
        sound: false,
        vibration: false,
        voice: false,
        highContrast: false,
        reduceMotion: prefersReduced.matches
    };

    const state = {
        status: 'idle',
        currentCycle: 1,
        phaseIndex: 0,
        elapsed: 0,
        raf: null,
        lastTick: null,
    };

    const circumference = 2 * Math.PI * 88;
    ring?.setAttribute('stroke-dasharray', `${circumference}`);
    ring?.setAttribute('stroke-dashoffset', `${circumference}`);

    const playTone = () => {
        try {
            const ctx = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator = ctx.createOscillator();
            const gainNode = ctx.createGain();
            oscillator.type = 'sine';
            oscillator.frequency.value = 520;
            gainNode.gain.value = 0.02;
            oscillator.connect(gainNode);
            gainNode.connect(ctx.destination);
            oscillator.start();
            oscillator.stop(ctx.currentTime + 0.18);
        } catch (error) {
            console.warn('Sound unavailable', error);
        }
    };

    const speakPhase = (text) => {
        if (!('speechSynthesis' in window)) return;
        const msg = new SpeechSynthesisUtterance(text);
        msg.rate = 1.05;
        msg.pitch = 1.1;
        msg.lang = 'en-GB';
        window.speechSynthesis.speak(msg);
    };

    const vibratePhase = () => {
        if (!('vibrate' in navigator)) return;
        navigator.vibrate(60);
    };

    const updateRing = (progress) => {
        if (!ring) return;
        const clamped = Math.min(Math.max(progress, 0), 1);
        ring.style.strokeDashoffset = `${circumference - clamped * circumference}`;
    };

    const formatRemaining = (seconds) => {
        const rounded = Math.max(0, Math.round(seconds));
        return `~${rounded}s left`;
    };

    const getRemainingSeconds = () => {
        const currentPhase = phases[state.phaseIndex];
        const elapsedSeconds = state.elapsed / 1000;
        const currentRemaining = Math.max(0, (currentPhase?.duration ?? 0) - elapsedSeconds);

        const upcoming = phases.slice(state.phaseIndex + 1).reduce((total, phase) => total + (phase.duration ?? 0), 0);
        const fullCyclesLeft = Math.max(0, settings.targetCycles - state.currentCycle);
        return currentRemaining + upcoming + fullCyclesLeft * totalCycleSeconds;
    };

    const setPhaseUI = () => {
        const currentPhase = phases[state.phaseIndex] ?? phases[0];
        const phaseKey = currentPhase?.phase ?? 'inhale';
        stage?.setAttribute('data-phase', phaseKey);

        if (phaseLabel) phaseLabel.textContent = phaseCopy[phaseKey] ?? 'Breathe';
        if (phaseInstruction) phaseInstruction.textContent = `${phaseCopy[phaseKey] ?? 'Breathe'} for ${currentPhase?.duration ?? 0}`;
        if (phaseCount) phaseCount.textContent = `${Math.max(1, Math.round((currentPhase?.duration ?? 0) - state.elapsed / 1000))}`;

        if (cycleDisplay) cycleDisplay.textContent = `Cycle ${state.currentCycle} of ${settings.targetCycles}`;
        if (remainingDisplay) remainingDisplay.textContent = formatRemaining(getRemainingSeconds());
    };

    const setControls = () => {
        if (!startBtn || !pauseBtn) return;
        let label = 'Start';
        if (state.status === 'paused') label = 'Resume';
        if (state.status === 'finished') label = 'Start';
        startBtn.textContent = label;
        startBtn.setAttribute('aria-disabled', state.status === 'running' ? 'true' : 'false');
        startBtn.disabled = state.status === 'running';

        pauseBtn.setAttribute('aria-disabled', state.status !== 'running' ? 'true' : 'false');
        pauseBtn.disabled = state.status !== 'running';
    };

    const adjustBreathScale = (progress) => {
        if (!circle) return;
        const currentPhase = phases[state.phaseIndex] ?? phases[0];
        const phaseKey = currentPhase?.phase ?? 'inhale';
        let scale = 1;

        if (settings.reduceMotion) {
            scale = 1;
        } else if (phaseKey === 'inhale') {
            scale = 1 + 0.14 * progress;
        } else if (phaseKey === 'hold') {
            scale = 1.14 + Math.sin(progress * Math.PI * 2) * 0.015;
        } else if (phaseKey === 'exhale') {
            scale = 1.14 - 0.18 * progress;
        }

        circle.style.setProperty('--scale', scale.toFixed(3));
    };

    const onPhaseTransition = () => {
        if (settings.sound) playTone();
        if (settings.vibration) vibratePhase();
        if (settings.voice) {
            const currentPhase = phases[state.phaseIndex] ?? phases[0];
            const phaseKey = currentPhase?.phase ?? 'Breathe';
            speakPhase(phaseCopy[phaseKey] ?? 'Breathe');
        }
    };

    const advancePhase = () => {
        state.phaseIndex += 1;
        state.elapsed = 0;

        if (state.phaseIndex >= phases.length) {
            state.phaseIndex = 0;
            state.currentCycle += 1;
        }

        if (state.currentCycle > settings.targetCycles) {
            completeSession();
            return;
        }

        onPhaseTransition();
        setPhaseUI();
    };

    const tick = (timestamp) => {
        if (state.status !== 'running') return;
        if (!state.lastTick) state.lastTick = timestamp;
        const delta = timestamp - state.lastTick;
        state.lastTick = timestamp;
        state.elapsed += delta;

        const currentPhase = phases[state.phaseIndex] ?? phases[0];
        const durationMs = (currentPhase?.duration ?? 0) * 1000;
        const progress = Math.min(state.elapsed / durationMs, 1);
        const countdown = Math.max(0, Math.ceil((durationMs - state.elapsed) / 1000));

        updateRing(progress);
        adjustBreathScale(progress);
        if (phaseCount) phaseCount.textContent = `${countdown}`;
        if (remainingDisplay) remainingDisplay.textContent = formatRemaining(getRemainingSeconds());

        if (state.elapsed >= durationMs) {
            advancePhase();
        }

        if (state.status === 'running') {
            state.raf = requestAnimationFrame(tick);
        }
    };

    const startSession = () => {
        if (state.status === 'running') return;
        if (state.status === 'paused') {
            state.status = 'running';
            state.lastTick = null;
            state.raf = requestAnimationFrame(tick);
            setControls();
            return;
        }

        state.status = 'running';
        state.currentCycle = 1;
        state.phaseIndex = 0;
        state.elapsed = 0;
        state.lastTick = null;
        setPhaseUI();
        updateRing(0);
        adjustBreathScale(0);
        state.raf = requestAnimationFrame(tick);
        setControls();
    };

    const pauseSession = () => {
        if (state.status !== 'running') return;
        state.status = 'paused';
        cancelAnimationFrame(state.raf);
        state.raf = null;
        setControls();
    };

    const completeSession = () => {
        cancelAnimationFrame(state.raf);
        state.status = 'finished';
        state.raf = null;
        state.lastTick = null;
        updateRing(1);
        adjustBreathScale(0);
        if (phaseLabel) phaseLabel.textContent = 'Completed';
        if (phaseInstruction) phaseInstruction.textContent = 'Tap restart for another round';
        if (phaseCount) phaseCount.textContent = '0';
        if (cycleDisplay) cycleDisplay.textContent = `Cycle ${settings.targetCycles} of ${settings.targetCycles}`;
        setControls();
    };

    const restartSession = () => {
        cancelAnimationFrame(state.raf);
        state.status = 'idle';
        state.currentCycle = 1;
        state.phaseIndex = 0;
        state.elapsed = 0;
        state.lastTick = null;
        updateRing(0);
        adjustBreathScale(0);
        setPhaseUI();
        setControls();
    };

    const runPreview = () => {
        if (state.status !== 'idle' && state.status !== 'finished') return;
        state.status = 'preview';
        let previewStep = 0;

        const doPreview = () => {
            previewStep += 1;
            if (previewStep === 1) {
                stage?.setAttribute('data-phase', 'inhale');
                if (phaseLabel) phaseLabel.textContent = 'Preview inhale';
                if (phaseInstruction) phaseInstruction.textContent = 'Quick inhale';
                updateRing(0.5);
                adjustBreathScale(0.6);
                setTimeout(doPreview, settings.reduceMotion ? 200 : 700);
            } else if (previewStep === 2) {
                stage?.setAttribute('data-phase', 'exhale');
                if (phaseLabel) phaseLabel.textContent = 'Preview exhale';
                if (phaseInstruction) phaseInstruction.textContent = 'Quick release';
                updateRing(1);
                adjustBreathScale(0.2);
                setTimeout(doPreview, settings.reduceMotion ? 200 : 700);
            } else {
                state.status = 'idle';
                restartSession();
            }
        };

        doPreview();
    };

    startBtn?.addEventListener('click', startSession);
    pauseBtn?.addEventListener('click', pauseSession);
    restartBtn?.addEventListener('click', restartSession);
    previewArea?.addEventListener('click', runPreview);

    cycleButtons.forEach((btn) => {
        btn.addEventListener('click', () => {
            const value = Number(btn.getAttribute('data-cycle-value'));
            settings.targetCycles = value;
            cycleButtons.forEach((b) => {
                b.classList.toggle('active', Number(b.getAttribute('data-cycle-value')) === value);
                b.setAttribute('aria-pressed', Number(b.getAttribute('data-cycle-value')) === value ? 'true' : 'false');
            });
            state.currentCycle = 1;
            setPhaseUI();
        });
    });

    toggleChips.forEach((chip) => {
        chip.addEventListener('click', () => {
            const key = chip.getAttribute('data-toggle');
            if (!key) return;
            const newValue = !(chip.getAttribute('aria-pressed') === 'true');
            chip.setAttribute('aria-pressed', newValue ? 'true' : 'false');
            chip.classList.toggle('active', newValue);

            if (key === 'sound') settings.sound = newValue;
            if (key === 'vibration') settings.vibration = newValue;
            if (key === 'voice') settings.voice = newValue;
            if (key === 'contrast') {
                settings.highContrast = newValue;
                root?.setAttribute('data-high-contrast', newValue ? 'true' : 'false');
            }
            if (key === 'reduce') {
                settings.reduceMotion = newValue || prefersReduced.matches;
                circle?.style.setProperty('--scale', '1');
            }
        });
    });

    prefersReduced.addEventListener('change', (event) => {
        settings.reduceMotion = event.matches;
        const reduceChip = document.querySelector('[data-toggle="reduce"]');
        if (reduceChip) {
            reduceChip.setAttribute('aria-pressed', settings.reduceMotion ? 'true' : 'false');
            reduceChip.classList.toggle('active', settings.reduceMotion);
        }
    });

    const reduceChip = document.querySelector('[data-toggle="reduce"]');
    if (reduceChip && settings.reduceMotion) {
        reduceChip.classList.add('active');
        reduceChip.setAttribute('aria-pressed', 'true');
    }

    setPhaseUI();
    setControls();
    updateRing(0);
    adjustBreathScale(0);
</script>
